#!/bin/bash
source $GS_INIT_PATH
__git-story-init

##########
#  done  #
##########

usage() {
  __gs-print "
usage:
\t git done
only if all changes have been committed.
otherwise run:
\t git done 'Commit message' <target_branch>
will fetch and merge <target_branch>. <target_branch> is optional and defaults to $GS_GIT_STORY_BRANCH.
note:"
  __gs-warning "\t Can cause merge conflicts"
}

main() {
  __gs-check-usage-param $1
  main-exec "$@"
}

main-exec() {
  git test

  if [[ $GS_PRINT_CHECKLIST == true ]]; then
    __gs-ready-checklist-print
    confirm_message="Have you answered yes to all of the above?"
  else
    confirm_message="Are your sure?"
  fi

  __gs-print ""

  if [[ $GS_PROMPT_ON_DONE  == true ]]; then
    __gs-continue-prompt "$confirm_message"
  fi
  gs-ready-execute "$@"
}

gs-ready-execute() {
  if [[ $(git status 2> /dev/null | tail -n1) != *"working directory clean"* ]]; then
    if [[ -z "$1" ]]; then
      __gs-error "You have uncommited changes you must provide a commit message."
      __gs-print "example: "
      __gs-print "\t git done 'Any message'"
      die
    fi
    git add --all
    git commit -m "$1"
  elif [[ ! -z "$1" ]]; then
    __gs-warning "Nothing to commit. Ignoring arguments."
  fi

  local current="$(__gs-current-branch)"
  __gs-sync-branch $current $current

  local target=${2:-master}
  __gs-sync-branch $target $current

  __gs-print ""
  __gs-success "Success."
}

# $1 : remote target
# $2 : current
__gs-sync-branch() {
  __gs-info "Pull from: '$1'"
  __gs-pull-and-check-status $1 $2
  git push $GS_DEFAULT_REMOTE $2
}

main "$@"
